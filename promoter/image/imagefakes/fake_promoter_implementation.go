/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by counterfeiter. DO NOT EDIT.
package imagefakes

import (
	"sync"

	inventory "sigs.k8s.io/promo-tools/v3/internal/legacy/dockerregistry"
	"sigs.k8s.io/promo-tools/v3/internal/legacy/dockerregistry/registry"
	"sigs.k8s.io/promo-tools/v3/internal/legacy/dockerregistry/schema"
	imagepromoterb "sigs.k8s.io/promo-tools/v3/internal/promoter/image"
	"sigs.k8s.io/promo-tools/v3/promoter/image/checkresults"
	imagepromotera "sigs.k8s.io/promo-tools/v3/promoter/image/options"
)

type FakePromoterImplementation struct {
	ActivateServiceAccountsStub        func(*imagepromotera.Options) error
	activateServiceAccountsMutex       sync.RWMutex
	activateServiceAccountsArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	activateServiceAccountsReturns struct {
		result1 error
	}
	activateServiceAccountsReturnsOnCall map[int]struct {
		result1 error
	}
	AppendManifestToSnapshotStub        func(*imagepromotera.Options, []schema.Manifest) ([]schema.Manifest, error)
	appendManifestToSnapshotMutex       sync.RWMutex
	appendManifestToSnapshotArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}
	appendManifestToSnapshotReturns struct {
		result1 []schema.Manifest
		result2 error
	}
	appendManifestToSnapshotReturnsOnCall map[int]struct {
		result1 []schema.Manifest
		result2 error
	}
	CopySignaturesStub        func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error
	copySignaturesMutex       sync.RWMutex
	copySignaturesArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}
	copySignaturesReturns struct {
		result1 error
	}
	copySignaturesReturnsOnCall map[int]struct {
		result1 error
	}
	FixMissingSignaturesStub        func(*imagepromotera.Options, checkresults.Signature) error
	fixMissingSignaturesMutex       sync.RWMutex
	fixMissingSignaturesArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 checkresults.Signature
	}
	fixMissingSignaturesReturns struct {
		result1 error
	}
	fixMissingSignaturesReturnsOnCall map[int]struct {
		result1 error
	}
	FixPartialSignaturesStub        func(*imagepromotera.Options, checkresults.Signature) error
	fixPartialSignaturesMutex       sync.RWMutex
	fixPartialSignaturesArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 checkresults.Signature
	}
	fixPartialSignaturesReturns struct {
		result1 error
	}
	fixPartialSignaturesReturnsOnCall map[int]struct {
		result1 error
	}
	GetLatestImagesStub        func(*imagepromotera.Options) ([]string, error)
	getLatestImagesMutex       sync.RWMutex
	getLatestImagesArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	getLatestImagesReturns struct {
		result1 []string
		result2 error
	}
	getLatestImagesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetPromotionEdgesStub        func(*inventory.SyncContext, []schema.Manifest) (map[inventory.PromotionEdge]interface{}, error)
	getPromotionEdgesMutex       sync.RWMutex
	getPromotionEdgesArgsForCall []struct {
		arg1 *inventory.SyncContext
		arg2 []schema.Manifest
	}
	getPromotionEdgesReturns struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	getPromotionEdgesReturnsOnCall map[int]struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	GetRegistryImageInventoryStub        func(*imagepromotera.Options, []schema.Manifest) (registry.RegInvImage, error)
	getRegistryImageInventoryMutex       sync.RWMutex
	getRegistryImageInventoryArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}
	getRegistryImageInventoryReturns struct {
		result1 registry.RegInvImage
		result2 error
	}
	getRegistryImageInventoryReturnsOnCall map[int]struct {
		result1 registry.RegInvImage
		result2 error
	}
	GetSignatureStatusStub        func(*imagepromotera.Options, []string) (checkresults.Signature, error)
	getSignatureStatusMutex       sync.RWMutex
	getSignatureStatusArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 []string
	}
	getSignatureStatusReturns struct {
		result1 checkresults.Signature
		result2 error
	}
	getSignatureStatusReturnsOnCall map[int]struct {
		result1 checkresults.Signature
		result2 error
	}
	GetSnapshotManifestsStub        func(*imagepromotera.Options) ([]schema.Manifest, error)
	getSnapshotManifestsMutex       sync.RWMutex
	getSnapshotManifestsArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	getSnapshotManifestsReturns struct {
		result1 []schema.Manifest
		result2 error
	}
	getSnapshotManifestsReturnsOnCall map[int]struct {
		result1 []schema.Manifest
		result2 error
	}
	GetSnapshotSourceRegistryStub        func(*imagepromotera.Options) (*registry.Context, error)
	getSnapshotSourceRegistryMutex       sync.RWMutex
	getSnapshotSourceRegistryArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	getSnapshotSourceRegistryReturns struct {
		result1 *registry.Context
		result2 error
	}
	getSnapshotSourceRegistryReturnsOnCall map[int]struct {
		result1 *registry.Context
		result2 error
	}
	MakeProducerFunctionStub        func(bool) imagepromoterb.StreamProducerFunc
	makeProducerFunctionMutex       sync.RWMutex
	makeProducerFunctionArgsForCall []struct {
		arg1 bool
	}
	makeProducerFunctionReturns struct {
		result1 imagepromoterb.StreamProducerFunc
	}
	makeProducerFunctionReturnsOnCall map[int]struct {
		result1 imagepromoterb.StreamProducerFunc
	}
	MakeSyncContextStub        func(*imagepromotera.Options, []schema.Manifest) (*inventory.SyncContext, error)
	makeSyncContextMutex       sync.RWMutex
	makeSyncContextArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}
	makeSyncContextReturns struct {
		result1 *inventory.SyncContext
		result2 error
	}
	makeSyncContextReturnsOnCall map[int]struct {
		result1 *inventory.SyncContext
		result2 error
	}
	ParseManifestsStub        func(*imagepromotera.Options) ([]schema.Manifest, error)
	parseManifestsMutex       sync.RWMutex
	parseManifestsArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	parseManifestsReturns struct {
		result1 []schema.Manifest
		result2 error
	}
	parseManifestsReturnsOnCall map[int]struct {
		result1 []schema.Manifest
		result2 error
	}
	PrecheckAndExitStub        func(*imagepromotera.Options, []schema.Manifest) error
	precheckAndExitMutex       sync.RWMutex
	precheckAndExitArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}
	precheckAndExitReturns struct {
		result1 error
	}
	precheckAndExitReturnsOnCall map[int]struct {
		result1 error
	}
	PrewarmTUFCacheStub        func() error
	prewarmTUFCacheMutex       sync.RWMutex
	prewarmTUFCacheArgsForCall []struct {
	}
	prewarmTUFCacheReturns struct {
		result1 error
	}
	prewarmTUFCacheReturnsOnCall map[int]struct {
		result1 error
	}
	PrintSecDisclaimerStub        func()
	printSecDisclaimerMutex       sync.RWMutex
	printSecDisclaimerArgsForCall []struct {
	}
	PrintSectionStub        func(string, bool)
	printSectionMutex       sync.RWMutex
	printSectionArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	PrintVersionStub        func()
	printVersionMutex       sync.RWMutex
	printVersionArgsForCall []struct {
	}
	PromoteImagesStub        func(*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, imagepromoterb.StreamProducerFunc) error
	promoteImagesMutex       sync.RWMutex
	promoteImagesArgsForCall []struct {
		arg1 *inventory.SyncContext
		arg2 map[inventory.PromotionEdge]interface{}
		arg3 imagepromoterb.StreamProducerFunc
	}
	promoteImagesReturns struct {
		result1 error
	}
	promoteImagesReturnsOnCall map[int]struct {
		result1 error
	}
	ScanEdgesStub        func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error
	scanEdgesMutex       sync.RWMutex
	scanEdgesArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}
	scanEdgesReturns struct {
		result1 error
	}
	scanEdgesReturnsOnCall map[int]struct {
		result1 error
	}
	SignImagesStub        func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error
	signImagesMutex       sync.RWMutex
	signImagesArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}
	signImagesReturns struct {
		result1 error
	}
	signImagesReturnsOnCall map[int]struct {
		result1 error
	}
	SnapshotStub        func(*imagepromotera.Options, registry.RegInvImage) error
	snapshotMutex       sync.RWMutex
	snapshotArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 registry.RegInvImage
	}
	snapshotReturns struct {
		result1 error
	}
	snapshotReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateManifestListsStub        func(*imagepromotera.Options) error
	validateManifestListsMutex       sync.RWMutex
	validateManifestListsArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	validateManifestListsReturns struct {
		result1 error
	}
	validateManifestListsReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateOptionsStub        func(*imagepromotera.Options) error
	validateOptionsMutex       sync.RWMutex
	validateOptionsArgsForCall []struct {
		arg1 *imagepromotera.Options
	}
	validateOptionsReturns struct {
		result1 error
	}
	validateOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateStagingSignaturesStub        func(map[inventory.PromotionEdge]interface{}) (map[inventory.PromotionEdge]interface{}, error)
	validateStagingSignaturesMutex       sync.RWMutex
	validateStagingSignaturesArgsForCall []struct {
		arg1 map[inventory.PromotionEdge]interface{}
	}
	validateStagingSignaturesReturns struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	validateStagingSignaturesReturnsOnCall map[int]struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}
	WriteSBOMsStub        func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error
	writeSBOMsMutex       sync.RWMutex
	writeSBOMsArgsForCall []struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}
	writeSBOMsReturns struct {
		result1 error
	}
	writeSBOMsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePromoterImplementation) ActivateServiceAccounts(arg1 *imagepromotera.Options) error {
	fake.activateServiceAccountsMutex.Lock()
	ret, specificReturn := fake.activateServiceAccountsReturnsOnCall[len(fake.activateServiceAccountsArgsForCall)]
	fake.activateServiceAccountsArgsForCall = append(fake.activateServiceAccountsArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.ActivateServiceAccountsStub
	fakeReturns := fake.activateServiceAccountsReturns
	fake.recordInvocation("ActivateServiceAccounts", []interface{}{arg1})
	fake.activateServiceAccountsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsCallCount() int {
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	return len(fake.activateServiceAccountsArgsForCall)
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsCalls(stub func(*imagepromotera.Options) error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = stub
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsArgsForCall(i int) *imagepromotera.Options {
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	argsForCall := fake.activateServiceAccountsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsReturns(result1 error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = nil
	fake.activateServiceAccountsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ActivateServiceAccountsReturnsOnCall(i int, result1 error) {
	fake.activateServiceAccountsMutex.Lock()
	defer fake.activateServiceAccountsMutex.Unlock()
	fake.ActivateServiceAccountsStub = nil
	if fake.activateServiceAccountsReturnsOnCall == nil {
		fake.activateServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.activateServiceAccountsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshot(arg1 *imagepromotera.Options, arg2 []schema.Manifest) ([]schema.Manifest, error) {
	var arg2Copy []schema.Manifest
	if arg2 != nil {
		arg2Copy = make([]schema.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.appendManifestToSnapshotMutex.Lock()
	ret, specificReturn := fake.appendManifestToSnapshotReturnsOnCall[len(fake.appendManifestToSnapshotArgsForCall)]
	fake.appendManifestToSnapshotArgsForCall = append(fake.appendManifestToSnapshotArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}{arg1, arg2Copy})
	stub := fake.AppendManifestToSnapshotStub
	fakeReturns := fake.appendManifestToSnapshotReturns
	fake.recordInvocation("AppendManifestToSnapshot", []interface{}{arg1, arg2Copy})
	fake.appendManifestToSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotCallCount() int {
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	return len(fake.appendManifestToSnapshotArgsForCall)
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotCalls(stub func(*imagepromotera.Options, []schema.Manifest) ([]schema.Manifest, error)) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = stub
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotArgsForCall(i int) (*imagepromotera.Options, []schema.Manifest) {
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	argsForCall := fake.appendManifestToSnapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotReturns(result1 []schema.Manifest, result2 error) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = nil
	fake.appendManifestToSnapshotReturns = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) AppendManifestToSnapshotReturnsOnCall(i int, result1 []schema.Manifest, result2 error) {
	fake.appendManifestToSnapshotMutex.Lock()
	defer fake.appendManifestToSnapshotMutex.Unlock()
	fake.AppendManifestToSnapshotStub = nil
	if fake.appendManifestToSnapshotReturnsOnCall == nil {
		fake.appendManifestToSnapshotReturnsOnCall = make(map[int]struct {
			result1 []schema.Manifest
			result2 error
		})
	}
	fake.appendManifestToSnapshotReturnsOnCall[i] = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) CopySignatures(arg1 *imagepromotera.Options, arg2 *inventory.SyncContext, arg3 map[inventory.PromotionEdge]interface{}) error {
	fake.copySignaturesMutex.Lock()
	ret, specificReturn := fake.copySignaturesReturnsOnCall[len(fake.copySignaturesArgsForCall)]
	fake.copySignaturesArgsForCall = append(fake.copySignaturesArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}{arg1, arg2, arg3})
	stub := fake.CopySignaturesStub
	fakeReturns := fake.copySignaturesReturns
	fake.recordInvocation("CopySignatures", []interface{}{arg1, arg2, arg3})
	fake.copySignaturesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) CopySignaturesCallCount() int {
	fake.copySignaturesMutex.RLock()
	defer fake.copySignaturesMutex.RUnlock()
	return len(fake.copySignaturesArgsForCall)
}

func (fake *FakePromoterImplementation) CopySignaturesCalls(stub func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error) {
	fake.copySignaturesMutex.Lock()
	defer fake.copySignaturesMutex.Unlock()
	fake.CopySignaturesStub = stub
}

func (fake *FakePromoterImplementation) CopySignaturesArgsForCall(i int) (*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) {
	fake.copySignaturesMutex.RLock()
	defer fake.copySignaturesMutex.RUnlock()
	argsForCall := fake.copySignaturesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) CopySignaturesReturns(result1 error) {
	fake.copySignaturesMutex.Lock()
	defer fake.copySignaturesMutex.Unlock()
	fake.CopySignaturesStub = nil
	fake.copySignaturesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) CopySignaturesReturnsOnCall(i int, result1 error) {
	fake.copySignaturesMutex.Lock()
	defer fake.copySignaturesMutex.Unlock()
	fake.CopySignaturesStub = nil
	if fake.copySignaturesReturnsOnCall == nil {
		fake.copySignaturesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copySignaturesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) FixMissingSignatures(arg1 *imagepromotera.Options, arg2 checkresults.Signature) error {
	fake.fixMissingSignaturesMutex.Lock()
	ret, specificReturn := fake.fixMissingSignaturesReturnsOnCall[len(fake.fixMissingSignaturesArgsForCall)]
	fake.fixMissingSignaturesArgsForCall = append(fake.fixMissingSignaturesArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 checkresults.Signature
	}{arg1, arg2})
	stub := fake.FixMissingSignaturesStub
	fakeReturns := fake.fixMissingSignaturesReturns
	fake.recordInvocation("FixMissingSignatures", []interface{}{arg1, arg2})
	fake.fixMissingSignaturesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) FixMissingSignaturesCallCount() int {
	fake.fixMissingSignaturesMutex.RLock()
	defer fake.fixMissingSignaturesMutex.RUnlock()
	return len(fake.fixMissingSignaturesArgsForCall)
}

func (fake *FakePromoterImplementation) FixMissingSignaturesCalls(stub func(*imagepromotera.Options, checkresults.Signature) error) {
	fake.fixMissingSignaturesMutex.Lock()
	defer fake.fixMissingSignaturesMutex.Unlock()
	fake.FixMissingSignaturesStub = stub
}

func (fake *FakePromoterImplementation) FixMissingSignaturesArgsForCall(i int) (*imagepromotera.Options, checkresults.Signature) {
	fake.fixMissingSignaturesMutex.RLock()
	defer fake.fixMissingSignaturesMutex.RUnlock()
	argsForCall := fake.fixMissingSignaturesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) FixMissingSignaturesReturns(result1 error) {
	fake.fixMissingSignaturesMutex.Lock()
	defer fake.fixMissingSignaturesMutex.Unlock()
	fake.FixMissingSignaturesStub = nil
	fake.fixMissingSignaturesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) FixMissingSignaturesReturnsOnCall(i int, result1 error) {
	fake.fixMissingSignaturesMutex.Lock()
	defer fake.fixMissingSignaturesMutex.Unlock()
	fake.FixMissingSignaturesStub = nil
	if fake.fixMissingSignaturesReturnsOnCall == nil {
		fake.fixMissingSignaturesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fixMissingSignaturesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) FixPartialSignatures(arg1 *imagepromotera.Options, arg2 checkresults.Signature) error {
	fake.fixPartialSignaturesMutex.Lock()
	ret, specificReturn := fake.fixPartialSignaturesReturnsOnCall[len(fake.fixPartialSignaturesArgsForCall)]
	fake.fixPartialSignaturesArgsForCall = append(fake.fixPartialSignaturesArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 checkresults.Signature
	}{arg1, arg2})
	stub := fake.FixPartialSignaturesStub
	fakeReturns := fake.fixPartialSignaturesReturns
	fake.recordInvocation("FixPartialSignatures", []interface{}{arg1, arg2})
	fake.fixPartialSignaturesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) FixPartialSignaturesCallCount() int {
	fake.fixPartialSignaturesMutex.RLock()
	defer fake.fixPartialSignaturesMutex.RUnlock()
	return len(fake.fixPartialSignaturesArgsForCall)
}

func (fake *FakePromoterImplementation) FixPartialSignaturesCalls(stub func(*imagepromotera.Options, checkresults.Signature) error) {
	fake.fixPartialSignaturesMutex.Lock()
	defer fake.fixPartialSignaturesMutex.Unlock()
	fake.FixPartialSignaturesStub = stub
}

func (fake *FakePromoterImplementation) FixPartialSignaturesArgsForCall(i int) (*imagepromotera.Options, checkresults.Signature) {
	fake.fixPartialSignaturesMutex.RLock()
	defer fake.fixPartialSignaturesMutex.RUnlock()
	argsForCall := fake.fixPartialSignaturesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) FixPartialSignaturesReturns(result1 error) {
	fake.fixPartialSignaturesMutex.Lock()
	defer fake.fixPartialSignaturesMutex.Unlock()
	fake.FixPartialSignaturesStub = nil
	fake.fixPartialSignaturesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) FixPartialSignaturesReturnsOnCall(i int, result1 error) {
	fake.fixPartialSignaturesMutex.Lock()
	defer fake.fixPartialSignaturesMutex.Unlock()
	fake.FixPartialSignaturesStub = nil
	if fake.fixPartialSignaturesReturnsOnCall == nil {
		fake.fixPartialSignaturesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fixPartialSignaturesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) GetLatestImages(arg1 *imagepromotera.Options) ([]string, error) {
	fake.getLatestImagesMutex.Lock()
	ret, specificReturn := fake.getLatestImagesReturnsOnCall[len(fake.getLatestImagesArgsForCall)]
	fake.getLatestImagesArgsForCall = append(fake.getLatestImagesArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.GetLatestImagesStub
	fakeReturns := fake.getLatestImagesReturns
	fake.recordInvocation("GetLatestImages", []interface{}{arg1})
	fake.getLatestImagesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetLatestImagesCallCount() int {
	fake.getLatestImagesMutex.RLock()
	defer fake.getLatestImagesMutex.RUnlock()
	return len(fake.getLatestImagesArgsForCall)
}

func (fake *FakePromoterImplementation) GetLatestImagesCalls(stub func(*imagepromotera.Options) ([]string, error)) {
	fake.getLatestImagesMutex.Lock()
	defer fake.getLatestImagesMutex.Unlock()
	fake.GetLatestImagesStub = stub
}

func (fake *FakePromoterImplementation) GetLatestImagesArgsForCall(i int) *imagepromotera.Options {
	fake.getLatestImagesMutex.RLock()
	defer fake.getLatestImagesMutex.RUnlock()
	argsForCall := fake.getLatestImagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) GetLatestImagesReturns(result1 []string, result2 error) {
	fake.getLatestImagesMutex.Lock()
	defer fake.getLatestImagesMutex.Unlock()
	fake.GetLatestImagesStub = nil
	fake.getLatestImagesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetLatestImagesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getLatestImagesMutex.Lock()
	defer fake.getLatestImagesMutex.Unlock()
	fake.GetLatestImagesStub = nil
	if fake.getLatestImagesReturnsOnCall == nil {
		fake.getLatestImagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getLatestImagesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetPromotionEdges(arg1 *inventory.SyncContext, arg2 []schema.Manifest) (map[inventory.PromotionEdge]interface{}, error) {
	var arg2Copy []schema.Manifest
	if arg2 != nil {
		arg2Copy = make([]schema.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getPromotionEdgesMutex.Lock()
	ret, specificReturn := fake.getPromotionEdgesReturnsOnCall[len(fake.getPromotionEdgesArgsForCall)]
	fake.getPromotionEdgesArgsForCall = append(fake.getPromotionEdgesArgsForCall, struct {
		arg1 *inventory.SyncContext
		arg2 []schema.Manifest
	}{arg1, arg2Copy})
	stub := fake.GetPromotionEdgesStub
	fakeReturns := fake.getPromotionEdgesReturns
	fake.recordInvocation("GetPromotionEdges", []interface{}{arg1, arg2Copy})
	fake.getPromotionEdgesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetPromotionEdgesCallCount() int {
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	return len(fake.getPromotionEdgesArgsForCall)
}

func (fake *FakePromoterImplementation) GetPromotionEdgesCalls(stub func(*inventory.SyncContext, []schema.Manifest) (map[inventory.PromotionEdge]interface{}, error)) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = stub
}

func (fake *FakePromoterImplementation) GetPromotionEdgesArgsForCall(i int) (*inventory.SyncContext, []schema.Manifest) {
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	argsForCall := fake.getPromotionEdgesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) GetPromotionEdgesReturns(result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = nil
	fake.getPromotionEdgesReturns = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetPromotionEdgesReturnsOnCall(i int, result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.getPromotionEdgesMutex.Lock()
	defer fake.getPromotionEdgesMutex.Unlock()
	fake.GetPromotionEdgesStub = nil
	if fake.getPromotionEdgesReturnsOnCall == nil {
		fake.getPromotionEdgesReturnsOnCall = make(map[int]struct {
			result1 map[inventory.PromotionEdge]interface{}
			result2 error
		})
	}
	fake.getPromotionEdgesReturnsOnCall[i] = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetRegistryImageInventory(arg1 *imagepromotera.Options, arg2 []schema.Manifest) (registry.RegInvImage, error) {
	var arg2Copy []schema.Manifest
	if arg2 != nil {
		arg2Copy = make([]schema.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getRegistryImageInventoryMutex.Lock()
	ret, specificReturn := fake.getRegistryImageInventoryReturnsOnCall[len(fake.getRegistryImageInventoryArgsForCall)]
	fake.getRegistryImageInventoryArgsForCall = append(fake.getRegistryImageInventoryArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}{arg1, arg2Copy})
	stub := fake.GetRegistryImageInventoryStub
	fakeReturns := fake.getRegistryImageInventoryReturns
	fake.recordInvocation("GetRegistryImageInventory", []interface{}{arg1, arg2Copy})
	fake.getRegistryImageInventoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryCallCount() int {
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	return len(fake.getRegistryImageInventoryArgsForCall)
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryCalls(stub func(*imagepromotera.Options, []schema.Manifest) (registry.RegInvImage, error)) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = stub
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryArgsForCall(i int) (*imagepromotera.Options, []schema.Manifest) {
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	argsForCall := fake.getRegistryImageInventoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryReturns(result1 registry.RegInvImage, result2 error) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = nil
	fake.getRegistryImageInventoryReturns = struct {
		result1 registry.RegInvImage
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetRegistryImageInventoryReturnsOnCall(i int, result1 registry.RegInvImage, result2 error) {
	fake.getRegistryImageInventoryMutex.Lock()
	defer fake.getRegistryImageInventoryMutex.Unlock()
	fake.GetRegistryImageInventoryStub = nil
	if fake.getRegistryImageInventoryReturnsOnCall == nil {
		fake.getRegistryImageInventoryReturnsOnCall = make(map[int]struct {
			result1 registry.RegInvImage
			result2 error
		})
	}
	fake.getRegistryImageInventoryReturnsOnCall[i] = struct {
		result1 registry.RegInvImage
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSignatureStatus(arg1 *imagepromotera.Options, arg2 []string) (checkresults.Signature, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getSignatureStatusMutex.Lock()
	ret, specificReturn := fake.getSignatureStatusReturnsOnCall[len(fake.getSignatureStatusArgsForCall)]
	fake.getSignatureStatusArgsForCall = append(fake.getSignatureStatusArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.GetSignatureStatusStub
	fakeReturns := fake.getSignatureStatusReturns
	fake.recordInvocation("GetSignatureStatus", []interface{}{arg1, arg2Copy})
	fake.getSignatureStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetSignatureStatusCallCount() int {
	fake.getSignatureStatusMutex.RLock()
	defer fake.getSignatureStatusMutex.RUnlock()
	return len(fake.getSignatureStatusArgsForCall)
}

func (fake *FakePromoterImplementation) GetSignatureStatusCalls(stub func(*imagepromotera.Options, []string) (checkresults.Signature, error)) {
	fake.getSignatureStatusMutex.Lock()
	defer fake.getSignatureStatusMutex.Unlock()
	fake.GetSignatureStatusStub = stub
}

func (fake *FakePromoterImplementation) GetSignatureStatusArgsForCall(i int) (*imagepromotera.Options, []string) {
	fake.getSignatureStatusMutex.RLock()
	defer fake.getSignatureStatusMutex.RUnlock()
	argsForCall := fake.getSignatureStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) GetSignatureStatusReturns(result1 checkresults.Signature, result2 error) {
	fake.getSignatureStatusMutex.Lock()
	defer fake.getSignatureStatusMutex.Unlock()
	fake.GetSignatureStatusStub = nil
	fake.getSignatureStatusReturns = struct {
		result1 checkresults.Signature
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSignatureStatusReturnsOnCall(i int, result1 checkresults.Signature, result2 error) {
	fake.getSignatureStatusMutex.Lock()
	defer fake.getSignatureStatusMutex.Unlock()
	fake.GetSignatureStatusStub = nil
	if fake.getSignatureStatusReturnsOnCall == nil {
		fake.getSignatureStatusReturnsOnCall = make(map[int]struct {
			result1 checkresults.Signature
			result2 error
		})
	}
	fake.getSignatureStatusReturnsOnCall[i] = struct {
		result1 checkresults.Signature
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotManifests(arg1 *imagepromotera.Options) ([]schema.Manifest, error) {
	fake.getSnapshotManifestsMutex.Lock()
	ret, specificReturn := fake.getSnapshotManifestsReturnsOnCall[len(fake.getSnapshotManifestsArgsForCall)]
	fake.getSnapshotManifestsArgsForCall = append(fake.getSnapshotManifestsArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.GetSnapshotManifestsStub
	fakeReturns := fake.getSnapshotManifestsReturns
	fake.recordInvocation("GetSnapshotManifests", []interface{}{arg1})
	fake.getSnapshotManifestsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsCallCount() int {
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	return len(fake.getSnapshotManifestsArgsForCall)
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsCalls(stub func(*imagepromotera.Options) ([]schema.Manifest, error)) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = stub
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsArgsForCall(i int) *imagepromotera.Options {
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	argsForCall := fake.getSnapshotManifestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsReturns(result1 []schema.Manifest, result2 error) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = nil
	fake.getSnapshotManifestsReturns = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotManifestsReturnsOnCall(i int, result1 []schema.Manifest, result2 error) {
	fake.getSnapshotManifestsMutex.Lock()
	defer fake.getSnapshotManifestsMutex.Unlock()
	fake.GetSnapshotManifestsStub = nil
	if fake.getSnapshotManifestsReturnsOnCall == nil {
		fake.getSnapshotManifestsReturnsOnCall = make(map[int]struct {
			result1 []schema.Manifest
			result2 error
		})
	}
	fake.getSnapshotManifestsReturnsOnCall[i] = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistry(arg1 *imagepromotera.Options) (*registry.Context, error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	ret, specificReturn := fake.getSnapshotSourceRegistryReturnsOnCall[len(fake.getSnapshotSourceRegistryArgsForCall)]
	fake.getSnapshotSourceRegistryArgsForCall = append(fake.getSnapshotSourceRegistryArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.GetSnapshotSourceRegistryStub
	fakeReturns := fake.getSnapshotSourceRegistryReturns
	fake.recordInvocation("GetSnapshotSourceRegistry", []interface{}{arg1})
	fake.getSnapshotSourceRegistryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryCallCount() int {
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	return len(fake.getSnapshotSourceRegistryArgsForCall)
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryCalls(stub func(*imagepromotera.Options) (*registry.Context, error)) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = stub
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryArgsForCall(i int) *imagepromotera.Options {
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	argsForCall := fake.getSnapshotSourceRegistryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryReturns(result1 *registry.Context, result2 error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = nil
	fake.getSnapshotSourceRegistryReturns = struct {
		result1 *registry.Context
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) GetSnapshotSourceRegistryReturnsOnCall(i int, result1 *registry.Context, result2 error) {
	fake.getSnapshotSourceRegistryMutex.Lock()
	defer fake.getSnapshotSourceRegistryMutex.Unlock()
	fake.GetSnapshotSourceRegistryStub = nil
	if fake.getSnapshotSourceRegistryReturnsOnCall == nil {
		fake.getSnapshotSourceRegistryReturnsOnCall = make(map[int]struct {
			result1 *registry.Context
			result2 error
		})
	}
	fake.getSnapshotSourceRegistryReturnsOnCall[i] = struct {
		result1 *registry.Context
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) MakeProducerFunction(arg1 bool) imagepromoterb.StreamProducerFunc {
	fake.makeProducerFunctionMutex.Lock()
	ret, specificReturn := fake.makeProducerFunctionReturnsOnCall[len(fake.makeProducerFunctionArgsForCall)]
	fake.makeProducerFunctionArgsForCall = append(fake.makeProducerFunctionArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.MakeProducerFunctionStub
	fakeReturns := fake.makeProducerFunctionReturns
	fake.recordInvocation("MakeProducerFunction", []interface{}{arg1})
	fake.makeProducerFunctionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) MakeProducerFunctionCallCount() int {
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	return len(fake.makeProducerFunctionArgsForCall)
}

func (fake *FakePromoterImplementation) MakeProducerFunctionCalls(stub func(bool) imagepromoterb.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = stub
}

func (fake *FakePromoterImplementation) MakeProducerFunctionArgsForCall(i int) bool {
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	argsForCall := fake.makeProducerFunctionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) MakeProducerFunctionReturns(result1 imagepromoterb.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = nil
	fake.makeProducerFunctionReturns = struct {
		result1 imagepromoterb.StreamProducerFunc
	}{result1}
}

func (fake *FakePromoterImplementation) MakeProducerFunctionReturnsOnCall(i int, result1 imagepromoterb.StreamProducerFunc) {
	fake.makeProducerFunctionMutex.Lock()
	defer fake.makeProducerFunctionMutex.Unlock()
	fake.MakeProducerFunctionStub = nil
	if fake.makeProducerFunctionReturnsOnCall == nil {
		fake.makeProducerFunctionReturnsOnCall = make(map[int]struct {
			result1 imagepromoterb.StreamProducerFunc
		})
	}
	fake.makeProducerFunctionReturnsOnCall[i] = struct {
		result1 imagepromoterb.StreamProducerFunc
	}{result1}
}

func (fake *FakePromoterImplementation) MakeSyncContext(arg1 *imagepromotera.Options, arg2 []schema.Manifest) (*inventory.SyncContext, error) {
	var arg2Copy []schema.Manifest
	if arg2 != nil {
		arg2Copy = make([]schema.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.makeSyncContextMutex.Lock()
	ret, specificReturn := fake.makeSyncContextReturnsOnCall[len(fake.makeSyncContextArgsForCall)]
	fake.makeSyncContextArgsForCall = append(fake.makeSyncContextArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}{arg1, arg2Copy})
	stub := fake.MakeSyncContextStub
	fakeReturns := fake.makeSyncContextReturns
	fake.recordInvocation("MakeSyncContext", []interface{}{arg1, arg2Copy})
	fake.makeSyncContextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) MakeSyncContextCallCount() int {
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	return len(fake.makeSyncContextArgsForCall)
}

func (fake *FakePromoterImplementation) MakeSyncContextCalls(stub func(*imagepromotera.Options, []schema.Manifest) (*inventory.SyncContext, error)) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = stub
}

func (fake *FakePromoterImplementation) MakeSyncContextArgsForCall(i int) (*imagepromotera.Options, []schema.Manifest) {
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	argsForCall := fake.makeSyncContextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) MakeSyncContextReturns(result1 *inventory.SyncContext, result2 error) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = nil
	fake.makeSyncContextReturns = struct {
		result1 *inventory.SyncContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) MakeSyncContextReturnsOnCall(i int, result1 *inventory.SyncContext, result2 error) {
	fake.makeSyncContextMutex.Lock()
	defer fake.makeSyncContextMutex.Unlock()
	fake.MakeSyncContextStub = nil
	if fake.makeSyncContextReturnsOnCall == nil {
		fake.makeSyncContextReturnsOnCall = make(map[int]struct {
			result1 *inventory.SyncContext
			result2 error
		})
	}
	fake.makeSyncContextReturnsOnCall[i] = struct {
		result1 *inventory.SyncContext
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) ParseManifests(arg1 *imagepromotera.Options) ([]schema.Manifest, error) {
	fake.parseManifestsMutex.Lock()
	ret, specificReturn := fake.parseManifestsReturnsOnCall[len(fake.parseManifestsArgsForCall)]
	fake.parseManifestsArgsForCall = append(fake.parseManifestsArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.ParseManifestsStub
	fakeReturns := fake.parseManifestsReturns
	fake.recordInvocation("ParseManifests", []interface{}{arg1})
	fake.parseManifestsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) ParseManifestsCallCount() int {
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	return len(fake.parseManifestsArgsForCall)
}

func (fake *FakePromoterImplementation) ParseManifestsCalls(stub func(*imagepromotera.Options) ([]schema.Manifest, error)) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = stub
}

func (fake *FakePromoterImplementation) ParseManifestsArgsForCall(i int) *imagepromotera.Options {
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	argsForCall := fake.parseManifestsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ParseManifestsReturns(result1 []schema.Manifest, result2 error) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = nil
	fake.parseManifestsReturns = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) ParseManifestsReturnsOnCall(i int, result1 []schema.Manifest, result2 error) {
	fake.parseManifestsMutex.Lock()
	defer fake.parseManifestsMutex.Unlock()
	fake.ParseManifestsStub = nil
	if fake.parseManifestsReturnsOnCall == nil {
		fake.parseManifestsReturnsOnCall = make(map[int]struct {
			result1 []schema.Manifest
			result2 error
		})
	}
	fake.parseManifestsReturnsOnCall[i] = struct {
		result1 []schema.Manifest
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) PrecheckAndExit(arg1 *imagepromotera.Options, arg2 []schema.Manifest) error {
	var arg2Copy []schema.Manifest
	if arg2 != nil {
		arg2Copy = make([]schema.Manifest, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.precheckAndExitMutex.Lock()
	ret, specificReturn := fake.precheckAndExitReturnsOnCall[len(fake.precheckAndExitArgsForCall)]
	fake.precheckAndExitArgsForCall = append(fake.precheckAndExitArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 []schema.Manifest
	}{arg1, arg2Copy})
	stub := fake.PrecheckAndExitStub
	fakeReturns := fake.precheckAndExitReturns
	fake.recordInvocation("PrecheckAndExit", []interface{}{arg1, arg2Copy})
	fake.precheckAndExitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) PrecheckAndExitCallCount() int {
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	return len(fake.precheckAndExitArgsForCall)
}

func (fake *FakePromoterImplementation) PrecheckAndExitCalls(stub func(*imagepromotera.Options, []schema.Manifest) error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = stub
}

func (fake *FakePromoterImplementation) PrecheckAndExitArgsForCall(i int) (*imagepromotera.Options, []schema.Manifest) {
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	argsForCall := fake.precheckAndExitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) PrecheckAndExitReturns(result1 error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = nil
	fake.precheckAndExitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PrecheckAndExitReturnsOnCall(i int, result1 error) {
	fake.precheckAndExitMutex.Lock()
	defer fake.precheckAndExitMutex.Unlock()
	fake.PrecheckAndExitStub = nil
	if fake.precheckAndExitReturnsOnCall == nil {
		fake.precheckAndExitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.precheckAndExitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PrewarmTUFCache() error {
	fake.prewarmTUFCacheMutex.Lock()
	ret, specificReturn := fake.prewarmTUFCacheReturnsOnCall[len(fake.prewarmTUFCacheArgsForCall)]
	fake.prewarmTUFCacheArgsForCall = append(fake.prewarmTUFCacheArgsForCall, struct {
	}{})
	stub := fake.PrewarmTUFCacheStub
	fakeReturns := fake.prewarmTUFCacheReturns
	fake.recordInvocation("PrewarmTUFCache", []interface{}{})
	fake.prewarmTUFCacheMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) PrewarmTUFCacheCallCount() int {
	fake.prewarmTUFCacheMutex.RLock()
	defer fake.prewarmTUFCacheMutex.RUnlock()
	return len(fake.prewarmTUFCacheArgsForCall)
}

func (fake *FakePromoterImplementation) PrewarmTUFCacheCalls(stub func() error) {
	fake.prewarmTUFCacheMutex.Lock()
	defer fake.prewarmTUFCacheMutex.Unlock()
	fake.PrewarmTUFCacheStub = stub
}

func (fake *FakePromoterImplementation) PrewarmTUFCacheReturns(result1 error) {
	fake.prewarmTUFCacheMutex.Lock()
	defer fake.prewarmTUFCacheMutex.Unlock()
	fake.PrewarmTUFCacheStub = nil
	fake.prewarmTUFCacheReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PrewarmTUFCacheReturnsOnCall(i int, result1 error) {
	fake.prewarmTUFCacheMutex.Lock()
	defer fake.prewarmTUFCacheMutex.Unlock()
	fake.PrewarmTUFCacheStub = nil
	if fake.prewarmTUFCacheReturnsOnCall == nil {
		fake.prewarmTUFCacheReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.prewarmTUFCacheReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PrintSecDisclaimer() {
	fake.printSecDisclaimerMutex.Lock()
	fake.printSecDisclaimerArgsForCall = append(fake.printSecDisclaimerArgsForCall, struct {
	}{})
	stub := fake.PrintSecDisclaimerStub
	fake.recordInvocation("PrintSecDisclaimer", []interface{}{})
	fake.printSecDisclaimerMutex.Unlock()
	if stub != nil {
		fake.PrintSecDisclaimerStub()
	}
}

func (fake *FakePromoterImplementation) PrintSecDisclaimerCallCount() int {
	fake.printSecDisclaimerMutex.RLock()
	defer fake.printSecDisclaimerMutex.RUnlock()
	return len(fake.printSecDisclaimerArgsForCall)
}

func (fake *FakePromoterImplementation) PrintSecDisclaimerCalls(stub func()) {
	fake.printSecDisclaimerMutex.Lock()
	defer fake.printSecDisclaimerMutex.Unlock()
	fake.PrintSecDisclaimerStub = stub
}

func (fake *FakePromoterImplementation) PrintSection(arg1 string, arg2 bool) {
	fake.printSectionMutex.Lock()
	fake.printSectionArgsForCall = append(fake.printSectionArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.PrintSectionStub
	fake.recordInvocation("PrintSection", []interface{}{arg1, arg2})
	fake.printSectionMutex.Unlock()
	if stub != nil {
		fake.PrintSectionStub(arg1, arg2)
	}
}

func (fake *FakePromoterImplementation) PrintSectionCallCount() int {
	fake.printSectionMutex.RLock()
	defer fake.printSectionMutex.RUnlock()
	return len(fake.printSectionArgsForCall)
}

func (fake *FakePromoterImplementation) PrintSectionCalls(stub func(string, bool)) {
	fake.printSectionMutex.Lock()
	defer fake.printSectionMutex.Unlock()
	fake.PrintSectionStub = stub
}

func (fake *FakePromoterImplementation) PrintSectionArgsForCall(i int) (string, bool) {
	fake.printSectionMutex.RLock()
	defer fake.printSectionMutex.RUnlock()
	argsForCall := fake.printSectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) PrintVersion() {
	fake.printVersionMutex.Lock()
	fake.printVersionArgsForCall = append(fake.printVersionArgsForCall, struct {
	}{})
	stub := fake.PrintVersionStub
	fake.recordInvocation("PrintVersion", []interface{}{})
	fake.printVersionMutex.Unlock()
	if stub != nil {
		fake.PrintVersionStub()
	}
}

func (fake *FakePromoterImplementation) PrintVersionCallCount() int {
	fake.printVersionMutex.RLock()
	defer fake.printVersionMutex.RUnlock()
	return len(fake.printVersionArgsForCall)
}

func (fake *FakePromoterImplementation) PrintVersionCalls(stub func()) {
	fake.printVersionMutex.Lock()
	defer fake.printVersionMutex.Unlock()
	fake.PrintVersionStub = stub
}

func (fake *FakePromoterImplementation) PromoteImages(arg1 *inventory.SyncContext, arg2 map[inventory.PromotionEdge]interface{}, arg3 imagepromoterb.StreamProducerFunc) error {
	fake.promoteImagesMutex.Lock()
	ret, specificReturn := fake.promoteImagesReturnsOnCall[len(fake.promoteImagesArgsForCall)]
	fake.promoteImagesArgsForCall = append(fake.promoteImagesArgsForCall, struct {
		arg1 *inventory.SyncContext
		arg2 map[inventory.PromotionEdge]interface{}
		arg3 imagepromoterb.StreamProducerFunc
	}{arg1, arg2, arg3})
	stub := fake.PromoteImagesStub
	fakeReturns := fake.promoteImagesReturns
	fake.recordInvocation("PromoteImages", []interface{}{arg1, arg2, arg3})
	fake.promoteImagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) PromoteImagesCallCount() int {
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	return len(fake.promoteImagesArgsForCall)
}

func (fake *FakePromoterImplementation) PromoteImagesCalls(stub func(*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, imagepromoterb.StreamProducerFunc) error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = stub
}

func (fake *FakePromoterImplementation) PromoteImagesArgsForCall(i int) (*inventory.SyncContext, map[inventory.PromotionEdge]interface{}, imagepromoterb.StreamProducerFunc) {
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	argsForCall := fake.promoteImagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) PromoteImagesReturns(result1 error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = nil
	fake.promoteImagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) PromoteImagesReturnsOnCall(i int, result1 error) {
	fake.promoteImagesMutex.Lock()
	defer fake.promoteImagesMutex.Unlock()
	fake.PromoteImagesStub = nil
	if fake.promoteImagesReturnsOnCall == nil {
		fake.promoteImagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.promoteImagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ScanEdges(arg1 *imagepromotera.Options, arg2 *inventory.SyncContext, arg3 map[inventory.PromotionEdge]interface{}) error {
	fake.scanEdgesMutex.Lock()
	ret, specificReturn := fake.scanEdgesReturnsOnCall[len(fake.scanEdgesArgsForCall)]
	fake.scanEdgesArgsForCall = append(fake.scanEdgesArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}{arg1, arg2, arg3})
	stub := fake.ScanEdgesStub
	fakeReturns := fake.scanEdgesReturns
	fake.recordInvocation("ScanEdges", []interface{}{arg1, arg2, arg3})
	fake.scanEdgesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ScanEdgesCallCount() int {
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	return len(fake.scanEdgesArgsForCall)
}

func (fake *FakePromoterImplementation) ScanEdgesCalls(stub func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = stub
}

func (fake *FakePromoterImplementation) ScanEdgesArgsForCall(i int) (*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) {
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	argsForCall := fake.scanEdgesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) ScanEdgesReturns(result1 error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = nil
	fake.scanEdgesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ScanEdgesReturnsOnCall(i int, result1 error) {
	fake.scanEdgesMutex.Lock()
	defer fake.scanEdgesMutex.Unlock()
	fake.ScanEdgesStub = nil
	if fake.scanEdgesReturnsOnCall == nil {
		fake.scanEdgesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanEdgesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) SignImages(arg1 *imagepromotera.Options, arg2 *inventory.SyncContext, arg3 map[inventory.PromotionEdge]interface{}) error {
	fake.signImagesMutex.Lock()
	ret, specificReturn := fake.signImagesReturnsOnCall[len(fake.signImagesArgsForCall)]
	fake.signImagesArgsForCall = append(fake.signImagesArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}{arg1, arg2, arg3})
	stub := fake.SignImagesStub
	fakeReturns := fake.signImagesReturns
	fake.recordInvocation("SignImages", []interface{}{arg1, arg2, arg3})
	fake.signImagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) SignImagesCallCount() int {
	fake.signImagesMutex.RLock()
	defer fake.signImagesMutex.RUnlock()
	return len(fake.signImagesArgsForCall)
}

func (fake *FakePromoterImplementation) SignImagesCalls(stub func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error) {
	fake.signImagesMutex.Lock()
	defer fake.signImagesMutex.Unlock()
	fake.SignImagesStub = stub
}

func (fake *FakePromoterImplementation) SignImagesArgsForCall(i int) (*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) {
	fake.signImagesMutex.RLock()
	defer fake.signImagesMutex.RUnlock()
	argsForCall := fake.signImagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) SignImagesReturns(result1 error) {
	fake.signImagesMutex.Lock()
	defer fake.signImagesMutex.Unlock()
	fake.SignImagesStub = nil
	fake.signImagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) SignImagesReturnsOnCall(i int, result1 error) {
	fake.signImagesMutex.Lock()
	defer fake.signImagesMutex.Unlock()
	fake.SignImagesStub = nil
	if fake.signImagesReturnsOnCall == nil {
		fake.signImagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signImagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) Snapshot(arg1 *imagepromotera.Options, arg2 registry.RegInvImage) error {
	fake.snapshotMutex.Lock()
	ret, specificReturn := fake.snapshotReturnsOnCall[len(fake.snapshotArgsForCall)]
	fake.snapshotArgsForCall = append(fake.snapshotArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 registry.RegInvImage
	}{arg1, arg2})
	stub := fake.SnapshotStub
	fakeReturns := fake.snapshotReturns
	fake.recordInvocation("Snapshot", []interface{}{arg1, arg2})
	fake.snapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) SnapshotCallCount() int {
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	return len(fake.snapshotArgsForCall)
}

func (fake *FakePromoterImplementation) SnapshotCalls(stub func(*imagepromotera.Options, registry.RegInvImage) error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = stub
}

func (fake *FakePromoterImplementation) SnapshotArgsForCall(i int) (*imagepromotera.Options, registry.RegInvImage) {
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	argsForCall := fake.snapshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePromoterImplementation) SnapshotReturns(result1 error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = nil
	fake.snapshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) SnapshotReturnsOnCall(i int, result1 error) {
	fake.snapshotMutex.Lock()
	defer fake.snapshotMutex.Unlock()
	fake.SnapshotStub = nil
	if fake.snapshotReturnsOnCall == nil {
		fake.snapshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.snapshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateManifestLists(arg1 *imagepromotera.Options) error {
	fake.validateManifestListsMutex.Lock()
	ret, specificReturn := fake.validateManifestListsReturnsOnCall[len(fake.validateManifestListsArgsForCall)]
	fake.validateManifestListsArgsForCall = append(fake.validateManifestListsArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.ValidateManifestListsStub
	fakeReturns := fake.validateManifestListsReturns
	fake.recordInvocation("ValidateManifestLists", []interface{}{arg1})
	fake.validateManifestListsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ValidateManifestListsCallCount() int {
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	return len(fake.validateManifestListsArgsForCall)
}

func (fake *FakePromoterImplementation) ValidateManifestListsCalls(stub func(*imagepromotera.Options) error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = stub
}

func (fake *FakePromoterImplementation) ValidateManifestListsArgsForCall(i int) *imagepromotera.Options {
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	argsForCall := fake.validateManifestListsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ValidateManifestListsReturns(result1 error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = nil
	fake.validateManifestListsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateManifestListsReturnsOnCall(i int, result1 error) {
	fake.validateManifestListsMutex.Lock()
	defer fake.validateManifestListsMutex.Unlock()
	fake.ValidateManifestListsStub = nil
	if fake.validateManifestListsReturnsOnCall == nil {
		fake.validateManifestListsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateManifestListsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateOptions(arg1 *imagepromotera.Options) error {
	fake.validateOptionsMutex.Lock()
	ret, specificReturn := fake.validateOptionsReturnsOnCall[len(fake.validateOptionsArgsForCall)]
	fake.validateOptionsArgsForCall = append(fake.validateOptionsArgsForCall, struct {
		arg1 *imagepromotera.Options
	}{arg1})
	stub := fake.ValidateOptionsStub
	fakeReturns := fake.validateOptionsReturns
	fake.recordInvocation("ValidateOptions", []interface{}{arg1})
	fake.validateOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) ValidateOptionsCallCount() int {
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	return len(fake.validateOptionsArgsForCall)
}

func (fake *FakePromoterImplementation) ValidateOptionsCalls(stub func(*imagepromotera.Options) error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = stub
}

func (fake *FakePromoterImplementation) ValidateOptionsArgsForCall(i int) *imagepromotera.Options {
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	argsForCall := fake.validateOptionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ValidateOptionsReturns(result1 error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = nil
	fake.validateOptionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateOptionsReturnsOnCall(i int, result1 error) {
	fake.validateOptionsMutex.Lock()
	defer fake.validateOptionsMutex.Unlock()
	fake.ValidateOptionsStub = nil
	if fake.validateOptionsReturnsOnCall == nil {
		fake.validateOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) ValidateStagingSignatures(arg1 map[inventory.PromotionEdge]interface{}) (map[inventory.PromotionEdge]interface{}, error) {
	fake.validateStagingSignaturesMutex.Lock()
	ret, specificReturn := fake.validateStagingSignaturesReturnsOnCall[len(fake.validateStagingSignaturesArgsForCall)]
	fake.validateStagingSignaturesArgsForCall = append(fake.validateStagingSignaturesArgsForCall, struct {
		arg1 map[inventory.PromotionEdge]interface{}
	}{arg1})
	stub := fake.ValidateStagingSignaturesStub
	fakeReturns := fake.validateStagingSignaturesReturns
	fake.recordInvocation("ValidateStagingSignatures", []interface{}{arg1})
	fake.validateStagingSignaturesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePromoterImplementation) ValidateStagingSignaturesCallCount() int {
	fake.validateStagingSignaturesMutex.RLock()
	defer fake.validateStagingSignaturesMutex.RUnlock()
	return len(fake.validateStagingSignaturesArgsForCall)
}

func (fake *FakePromoterImplementation) ValidateStagingSignaturesCalls(stub func(map[inventory.PromotionEdge]interface{}) (map[inventory.PromotionEdge]interface{}, error)) {
	fake.validateStagingSignaturesMutex.Lock()
	defer fake.validateStagingSignaturesMutex.Unlock()
	fake.ValidateStagingSignaturesStub = stub
}

func (fake *FakePromoterImplementation) ValidateStagingSignaturesArgsForCall(i int) map[inventory.PromotionEdge]interface{} {
	fake.validateStagingSignaturesMutex.RLock()
	defer fake.validateStagingSignaturesMutex.RUnlock()
	argsForCall := fake.validateStagingSignaturesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePromoterImplementation) ValidateStagingSignaturesReturns(result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.validateStagingSignaturesMutex.Lock()
	defer fake.validateStagingSignaturesMutex.Unlock()
	fake.ValidateStagingSignaturesStub = nil
	fake.validateStagingSignaturesReturns = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) ValidateStagingSignaturesReturnsOnCall(i int, result1 map[inventory.PromotionEdge]interface{}, result2 error) {
	fake.validateStagingSignaturesMutex.Lock()
	defer fake.validateStagingSignaturesMutex.Unlock()
	fake.ValidateStagingSignaturesStub = nil
	if fake.validateStagingSignaturesReturnsOnCall == nil {
		fake.validateStagingSignaturesReturnsOnCall = make(map[int]struct {
			result1 map[inventory.PromotionEdge]interface{}
			result2 error
		})
	}
	fake.validateStagingSignaturesReturnsOnCall[i] = struct {
		result1 map[inventory.PromotionEdge]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePromoterImplementation) WriteSBOMs(arg1 *imagepromotera.Options, arg2 *inventory.SyncContext, arg3 map[inventory.PromotionEdge]interface{}) error {
	fake.writeSBOMsMutex.Lock()
	ret, specificReturn := fake.writeSBOMsReturnsOnCall[len(fake.writeSBOMsArgsForCall)]
	fake.writeSBOMsArgsForCall = append(fake.writeSBOMsArgsForCall, struct {
		arg1 *imagepromotera.Options
		arg2 *inventory.SyncContext
		arg3 map[inventory.PromotionEdge]interface{}
	}{arg1, arg2, arg3})
	stub := fake.WriteSBOMsStub
	fakeReturns := fake.writeSBOMsReturns
	fake.recordInvocation("WriteSBOMs", []interface{}{arg1, arg2, arg3})
	fake.writeSBOMsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePromoterImplementation) WriteSBOMsCallCount() int {
	fake.writeSBOMsMutex.RLock()
	defer fake.writeSBOMsMutex.RUnlock()
	return len(fake.writeSBOMsArgsForCall)
}

func (fake *FakePromoterImplementation) WriteSBOMsCalls(stub func(*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) error) {
	fake.writeSBOMsMutex.Lock()
	defer fake.writeSBOMsMutex.Unlock()
	fake.WriteSBOMsStub = stub
}

func (fake *FakePromoterImplementation) WriteSBOMsArgsForCall(i int) (*imagepromotera.Options, *inventory.SyncContext, map[inventory.PromotionEdge]interface{}) {
	fake.writeSBOMsMutex.RLock()
	defer fake.writeSBOMsMutex.RUnlock()
	argsForCall := fake.writeSBOMsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePromoterImplementation) WriteSBOMsReturns(result1 error) {
	fake.writeSBOMsMutex.Lock()
	defer fake.writeSBOMsMutex.Unlock()
	fake.WriteSBOMsStub = nil
	fake.writeSBOMsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) WriteSBOMsReturnsOnCall(i int, result1 error) {
	fake.writeSBOMsMutex.Lock()
	defer fake.writeSBOMsMutex.Unlock()
	fake.WriteSBOMsStub = nil
	if fake.writeSBOMsReturnsOnCall == nil {
		fake.writeSBOMsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeSBOMsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePromoterImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activateServiceAccountsMutex.RLock()
	defer fake.activateServiceAccountsMutex.RUnlock()
	fake.appendManifestToSnapshotMutex.RLock()
	defer fake.appendManifestToSnapshotMutex.RUnlock()
	fake.copySignaturesMutex.RLock()
	defer fake.copySignaturesMutex.RUnlock()
	fake.fixMissingSignaturesMutex.RLock()
	defer fake.fixMissingSignaturesMutex.RUnlock()
	fake.fixPartialSignaturesMutex.RLock()
	defer fake.fixPartialSignaturesMutex.RUnlock()
	fake.getLatestImagesMutex.RLock()
	defer fake.getLatestImagesMutex.RUnlock()
	fake.getPromotionEdgesMutex.RLock()
	defer fake.getPromotionEdgesMutex.RUnlock()
	fake.getRegistryImageInventoryMutex.RLock()
	defer fake.getRegistryImageInventoryMutex.RUnlock()
	fake.getSignatureStatusMutex.RLock()
	defer fake.getSignatureStatusMutex.RUnlock()
	fake.getSnapshotManifestsMutex.RLock()
	defer fake.getSnapshotManifestsMutex.RUnlock()
	fake.getSnapshotSourceRegistryMutex.RLock()
	defer fake.getSnapshotSourceRegistryMutex.RUnlock()
	fake.makeProducerFunctionMutex.RLock()
	defer fake.makeProducerFunctionMutex.RUnlock()
	fake.makeSyncContextMutex.RLock()
	defer fake.makeSyncContextMutex.RUnlock()
	fake.parseManifestsMutex.RLock()
	defer fake.parseManifestsMutex.RUnlock()
	fake.precheckAndExitMutex.RLock()
	defer fake.precheckAndExitMutex.RUnlock()
	fake.prewarmTUFCacheMutex.RLock()
	defer fake.prewarmTUFCacheMutex.RUnlock()
	fake.printSecDisclaimerMutex.RLock()
	defer fake.printSecDisclaimerMutex.RUnlock()
	fake.printSectionMutex.RLock()
	defer fake.printSectionMutex.RUnlock()
	fake.printVersionMutex.RLock()
	defer fake.printVersionMutex.RUnlock()
	fake.promoteImagesMutex.RLock()
	defer fake.promoteImagesMutex.RUnlock()
	fake.scanEdgesMutex.RLock()
	defer fake.scanEdgesMutex.RUnlock()
	fake.signImagesMutex.RLock()
	defer fake.signImagesMutex.RUnlock()
	fake.snapshotMutex.RLock()
	defer fake.snapshotMutex.RUnlock()
	fake.validateManifestListsMutex.RLock()
	defer fake.validateManifestListsMutex.RUnlock()
	fake.validateOptionsMutex.RLock()
	defer fake.validateOptionsMutex.RUnlock()
	fake.validateStagingSignaturesMutex.RLock()
	defer fake.validateStagingSignaturesMutex.RUnlock()
	fake.writeSBOMsMutex.RLock()
	defer fake.writeSBOMsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePromoterImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
